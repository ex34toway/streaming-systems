# 第一章 流式 101

大数据处理中的流式数据处理日益盛行，究其原因主要有以下几点:

* 企业期望更加及时的洞察数据，切换到流式进行处理以降低延迟是一个不错的选择

* 当今商业环境更多大量，无界的数据集普遍出现，需要对应的系统来处理这样的数据

* 数据到达后立即被处理，可以更好的使用资源和保证资源的一致性

尽管商业上对于流式系统的需求很强，但是长期而来，流式系统依旧不够成熟。目前这一事情有所缓解，我认为主要是我的[”流式101“](https://www.oreilly.com/radar/the-world-beyond-batch-streaming-101/)和[”流式102“](https://www.oreilly.com/radar/the-world-beyond-batch-streaming-102/)（本书的前几章是关于显然是基于此）两篇博客的刺激，目前工业界有很多人期望看到流式的蓬勃发展，也有很多同僚热衷于此。

尽管在前期的战斗中有一些收货，但是我依旧会强调一下在[”流式101“](https://www.oreilly.com/radar/the-world-beyond-batch-streaming-101/)中的一些概念，避免很多读者并不知道这个前置信息。本书是在这些观点基础上的一些发展。

开始之前，我们先确定一些在后面的章节可能会提到的专有概念:

**概念**

要准确地谈论复杂的主题，需要对概念有个清晰的定义。对于某些在当前使用中解释过多的术语，我会尽力确切地说出我想表达的意义。

**应用**

我认为，流式系统有它的缺点。也提出构建数据处理系统需要以解决现代数据消费者的需求向前发展。

**时域**

我介绍了与数据相关的两种主要时间处理，并展示它们之间是如何影响的，并指出处理这两种时间的一些困难。

**概念: 什么是流?**

先明确一下，什么是流？流现在含义众多（
为简单起见，到目前为止我一直在稍微简单地使用它），而且容易让人误入歧途。所以，我想重新定义流的定义。

关键问题是，过去更多的时候我们用”多少“来描述流（比如，有多少数据经过处理引擎），更多的时候其实应该用”什么“来描述（无界数据处理, 近似结果, 等等）。由于缺少这些精确的定义。导致流式系统长期依赖代表不精确和推测的结果。

一个精心设计的流式系统应该可以像批系统一样产出，正确的，一致的，可复现的结果。我倾向于给流一个特殊的定义：

**流式系统**: 用来处理无界数据集的数据处理引擎

假如我想来说低延迟、近似或者推测的结果，我会直接使用这些术语，而不是简单的说他们是流。

在我们讨论不同类型的数据的时候，精确的术语也是很重要的。在我看来，有两个重要的（也是正交的）维度来对一个数据集进行定义: 数据集的大小（cardinality）和数据的模型（constitution）。

在这里，我通常会使用两个专门的术语来粗略的描述数据集的大小:

**有界数据**: 一类数据有限的大小。

**无界数据**: 一类数据无限制的大小(至少理论上是这样的)。

了解被处理的数据的数据集大小是重要的，因为处理无界数据会面临更多的挑战，更多的细节会在后面讲行讨论。

另一方面，数据模型描述了对于数据的抽象，并且决定了数据的交互形式，目前不深入介绍，在第六章，将给深入的介绍，目前给出两个基础的表示方式：

**表**

在某一时刻对历史数据的视图。传统上，SQL系统就是用表格呈现数据的

**流**

随着时间，一个接一个的数据元素。传统上，MapReduce式处理系统处理的数据就是流

在第六、八、九章中，讲更加深入的介绍表与流之间的关系，在第八章将学到它们随着时间变化的一些联系。但是，现在我们主要介绍流的，因为目前有很多开发人员直接参与大多数数据处理系统进行程序开发（包括批处理和流处理）。当然，这也体现的开发流式处理系统是有其自身的挑战。

**流处理的局限性**

接下来让我们明确一下流系统可以做什么和不能做什么。从历史上看，流式系统一直局限于提供低延迟，不准确或推测性结果的小众市场，通常与功能更强大的批处理系统结合使用，以提供最终正确的结果。换句话说，它其实就是Lambda架构。

Lambda架构的基本思想是运行两套系统，一套是流式的，一套是批量的，做同样的计算和处理，流式系统给一个低延迟的，但是不精确的结果。正确的结果，需要批量系统后续给出。这个概念最初由Twitter的Nathan Marz（也是[Storm](http://storm.apache.org/)的作者）提出。在当时的场景下，这样一个概念十分受到欢迎。但是Lambda也存在明显的问题，同时维护两套系统的代价和成本都很高，而且还要最终合并两条数据链路的结果。

本人一直比较支持强一致的流式系统，同样比较赞成Jay Kreps（Kafka的作者之一）的文章["Questioning The Lambda Architecture"](https://www.oreilly.com/radar/questioning-the-lambda-architecture/)，Kreps使用可重放系统（类似Kafka，用作流式连接器）解决了上下文重复性问题，他提出了Kappa架构，利用单个系统来实现需求，而不是利用流式和批处理两套系统。我不认同一个架构名称需要使用自己的希腊字母名称，但是我原则上完全支持这个想法。:)



