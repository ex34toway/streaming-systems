# 第一章 流式 101

大数据处理中的流式数据处理日益盛行，究其原因主要有以下几点:

* 企业期望更加及时的洞察数据，切换到流式进行处理以降低延迟是一个不错的选择

* 当今商业环境更多大量，无界的数据集普遍出现，需要对应的系统来处理这样的数据

* 数据到达后立即被处理，可以更好的使用资源和保证资源的一致性

尽管商业上对于流式系统的需求很强，但是长期而来，流式系统依旧不够成熟。目前这一事情有所缓解，我认为主要是我的[”流式101“](https://www.oreilly.com/radar/the-world-beyond-batch-streaming-101/)和[”流式102“](https://www.oreilly.com/radar/the-world-beyond-batch-streaming-102/)（本书的前几章是关于显然是基于此）两篇博客的刺激，目前工业界有很多人期望看到流式的蓬勃发展，也有很多同僚热衷于此。

尽管在前期的战斗中有一些收货，但是我依旧会强调一下在[”流式101“](https://www.oreilly.com/radar/the-world-beyond-batch-streaming-101/)中的一些概念，避免很多读者并不知道这个前置信息。本书是在这些观点基础上的一些发展。

开始之前，我们先确定一些在后面的章节可能会提到的专有概念:

**概念**

要准确地谈论复杂的主题，需要对概念有个清晰的定义。对于某些在当前使用中解释过多的术语，我会尽力确切地说出我想表达的意义。

**应用**

我认为，流式系统有它的缺点。也提出构建数据处理系统需要以解决现代数据消费者的需求向前发展。

**时域**

我介绍了与数据相关的两种主要时间处理，并展示它们之间是如何影响的，并指出处理这两种时间的一些困难。

**概念: 什么是流?**

先明确一下，什么是流？流现在含义众多（
为简单起见，到目前为止我一直在稍微简单地使用它），而且容易让人误入歧途。所以，我想重新定义流的定义。

关键问题是，过去更多的时候我们用”多少“来描述流（比如，有多少数据经过处理引擎），更多的时候其实应该用”什么“来描述（无界数据处理, 近似结果, 等等）。由于缺少这些精确的定义。导致流式系统长期依赖代表不精确和推测的结果。

一个精心设计的流式系统应该可以像批系统一样产出，正确的，一致的，可复现的结果。我倾向于给流一个特殊的定义：

**流式系统**: 用来处理无界数据集的数据处理引擎

假如我想来说低延迟、近似或者推测的结果，我会直接使用这些术语，而不是简单的说他们是流。

在我们讨论不同类型的数据的时候，精确的术语也是很重要的。在我看来，有两个重要的（也是正交的）维度来对一个数据集进行定义: 数据集的大小（cardinality）和数据的模型（constitution）。

在这里，我通常会使用两个专门的术语来粗略的描述数据集的大小:

**有界数据**: 一类数据有限的大小。

**无界数据**: 一类数据无限制的大小(至少理论上是这样的)。

了解被处理的数据的数据集大小是重要的，因为处理无界数据会面临更多的挑战，更多的细节会在后面讲行讨论。

另一方面，数据模型描述了对于数据的抽象，并且决定了数据的交互形式，目前不深入介绍，在第六章，将给深入的介绍，目前给出两个基础的表示方式：

**表**

在某一时刻对历史数据的视图。传统上，SQL系统就是用表格呈现数据的

**流**

随着时间，一个接一个的数据元素。传统上，MapReduce式处理系统处理的数据就是流

在第六、八、九章中，讲更加深入的介绍表与流之间的关系，在第八章将学到它们随着时间变化的一些联系。但是，现在我们主要介绍流的，因为目前有很多开发人员直接参与大多数数据处理系统进行程序开发（包括批处理和流处理）。当然，这也体现的开发流式处理系统是有其自身的挑战。

**流处理的局限性**

接下来让我们明确一下流系统可以做什么和不能做什么。从历史上看，流式系统一直局限于提供低延迟，不准确或推测性结果的小众市场，通常与功能更强大的批处理系统结合使用，以提供最终正确的结果。换句话说，它其实就是Lambda架构。

Lambda架构的基本思想是运行两套系统，一套是流式的，一套是批量的，做同样的计算和处理，流式系统给一个低延迟的，但是不精确的结果。正确的结果，需要批量系统后续给出。这个概念最初由Twitter的Nathan Marz（也是[Storm](http://storm.apache.org/)的作者）提出。在当时的场景下，这样一个概念十分受到欢迎。但是Lambda也存在明显的问题，同时维护两套系统的代价和成本都很高，而且还要最终合并两条数据链路的结果。

我一直比较支持强一致的流式系统，同样比较赞成Jay Kreps（Kafka的作者之一）的文章["Questioning The Lambda Architecture"](https://www.oreilly.com/radar/questioning-the-lambda-architecture/)，Kreps使用可重放系统（类似Kafka，用作流式连接器）解决了上下文重复性问题，他提出了Kappa架构，利用单个系统来实现需求，而不是利用流式和批处理两套系统。我不认同一个架构名称需要使用自己的希腊字母名称，但是我原则上完全支持这个想法。:)

老实说，我会更进一步。我会说好的流系统设计实际上应该包含批处理系统的所有功能，或者说，流系统应是批处理系统的超集。当前应该没有必要存在批处理系统的。同时，向Apache Flink员工表示敬意，希望他们牢记这个想法，并建立一个真正的流式处理系统: 在任何时间，将所有信息流式传输，即使在批处理模式下；我喜欢它。

流处理系统的广泛成熟是结合了强大的框架进行无界数据处理将及时允许将Lambda架构降级到上古时代它所属的数据历史记录。我相信现在是时候让它成为一个现实。

流处理系统结合了强大的框架进行无界数据处理, 现在是时候把Lambda架构放到它该放的大数据处理的历史长廊里了。因为这样做（也就是说，流胜过批处理），您真的只需要两件事:

**正确性**

在这一点上，流处理与批处理是一致的。核心是归结为
一致的存储。流系统需要一种检查点（Checkpointing）的方法持续的状态（Kreps在他的[“为什么局部状态是流处理中的基本原语”](https://www.oreilly.com/content/why-local-state-is-a-fundamental-primitive-in-stream-processing/)，并且它必须设计得足够好，以根据机器保持一致失败。当Spark框架首次出现在公共大数据中时几年前的场景，这是流式处理需要强一致性的立标。值得庆幸的是，目前情况已大大改善。但是，值得注意的是，目前仍然有一些流式系统，在没有很强一致性存储情况下，尝试流式数据处理...

重申一点，对于精确一次(Exactly-once)的处理方式，强一致性是必要条件，而且对于任何想对齐和超越批量系统的流式系统，强一致性都是不可或缺的。除非你只是真的不在乎您的结果，我恳请您避免任何流式传输无法提供高度一致状态的系统。批处理系统不要求您提前核实它们是否能够生产正确答案;不要将时间浪费在流式系统处理上，因为这样是无法得到相同结果的。

如果您想了解更多有关增强能力的知识流系统的一致性，建议您检查一下
[MillWheel](https://static.googleusercontent.com/media/research.google.com/zh-CN//pubs/archive/41378.pdf)、[Spark Streaming](https://people.csail.mit.edu/matei/papers/2012/hotcloud_spark_streaming.pdf)和[Flink snapshotting](https://arxiv.org/pdf/1506.08603.pdf)的论文。这三个人都花费大量时间讨论一致性。鲁文（Reuven）将在第五章中介绍一致性保证。

**合理的时间处理工具**

这是流式系统优于批量系统的地方。一个好的时间处理工具对处理无界数据是十分必要的。现在越来越多的数据集展示了这些特性，现有的批处理系统（以及许多流系统）缺少必要的工具来应对它们带来的困难（尽管现在我写这篇文章时，它正在迅速改变）。我们会花本书的大部分内容解释这一块的内容。

首先，我们对*时域*概念有基本的了解，之后我们将更深入地了解变化的事件是时间偏斜的无界、无序数据。然后我们花本章的其余部分介绍使用批处理和流系统进行有界和无界数据处理的常见方法。

**事件时间(Event time) VS 处理时间(Processing Time)**


要说明无界数据的处理需要明确了解所涉及的时间范围。在任何数据处理系统中，通常我们关心两个时间域：

**事件时间(Event time)**

事件实际发生的时间

**处理时间(Processing time)**

系统处理事件的时间

并非所有用例都关心事件的时间（如果您不关心事件的发生，太好了！那样处理起来会更加轻松）。但事实上，很多处理系统都需要对时间的处理。比如：包括表征用户行为随着时间的流逝，大多数计费应用程序以及许多异常行为的检测。

在理想的情况下，事件时间和处理时间将始终相等，事件发生时会立即进行处理。现实并非如是，事件时间和处理时间之间通常存在着的偏差(Time skew)。下面例举一些可能影响这个偏差的因素：

* 共享资源限制，例如网络拥塞，网络分区或非专用环境中的共享CPU

* 软件原因，例如分布式系统逻辑，竞争等等上

* 数据自身的原因，例如密钥分配，吞吐量或无序变化，而导致数据离线或者上线


如果您以任意时间绘制事件时间和处理时间的进度
真实系统，最终结果就像Figure 1-1


 ![Figure 1-1](../../res/part1/chapter1/Figure_1-1.png)
 
 Figure 1-1. Time-domain mapping. The x-axis represents event-time completeness in the






